<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Manifest Hash Checker</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            color-scheme: light dark;
            --bg: #1a1f2e;
            --text: #e0e6f2;
            --border: #2a3242;
            --hover: #2d344c;
            --primary: #4a74c9;
            --primary-dark: #385fa8;
            --primary-light: #6189d8;
            --metallic: linear-gradient(145deg, #2a3242, #1e2433);
            --metallic-hover: linear-gradient(145deg, #2d344c, #212737);
            --accent: #64b5f6;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }

        /* Base styles */
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: var(--metallic);
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            margin: 0;
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header h1 .material-icons {
            font-size: 2rem;
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Dropzone container */
        .dropzones {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .dropzone {
            flex: 1;
            border: 2px dashed var(--primary);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            background: var(--metallic);
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .dropzone .material-icons {
            font-size: 2.5rem;
            color: var(--primary-light);
        }

        .dropzone:hover, .dropzone.drag-over {
            background: var(--metallic-hover);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }

        /* Section styles */
        .section {
            background: var(--metallic);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            color: var(--primary-light);
            margin: 0 0 1.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Progress tracking */
        .progress-container {
            margin: 1.5rem 0;
            background: var(--metallic);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            width: 0;
            transition: width 0.3s ease;
        }

        .progress-stats {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .progress-text {
            font-size: 0.9rem;
            color: var(--text);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .progress-details {
            font-size: 0.875rem;
            color: var(--accent);
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .progress-details span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }

        .progress-details .material-icons {
            font-size: 1rem;
        }

        /* Table styles */
        .table-container {
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: rgba(42, 50, 66, 0.5);
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }

        th {
            position: sticky;
            top: 0;
            background: var(--primary-dark);
            color: var(--text);
            border-bottom: 2px solid var(--border);
            padding: 0.75rem 1rem;
            font-weight: 500;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        tr:hover td {
            background: var(--hover);
        }

        /* Search input */
		.search-container {
			margin-bottom: 1rem;
			position: relative;
			padding: 0.5rem;
			background: var(--metallic);
			border-radius: 8px;
			border: 1px solid var(--border);
		}
		
		.search {
			width: 100%;
			padding: 0.75rem 1rem 0.75rem 2.5rem;
			border: 1px solid var(--border);
			border-radius: 8px;
			background: rgba(42, 50, 66, 0.5);
			color: var(--text);
			font-size: 0.9rem;
			transition: all 0.3s ease;
			box-sizing: border-box;
		}
		
		.search-icon {
			position: absolute;
			left: 1.25rem;
			top: 50%;
			transform: translateY(-50%);
			color: var(--accent);
			font-size: 1.25rem;
			pointer-events: none;
		}

        .search:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(74, 116, 201, 0.2);
        }

        /* Status indicators */
        .status {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .status .material-icons {
            font-size: 1rem;
        }

        .match { color: var(--success); }
        .mismatch { color: var(--error); }
        .pending { color: var(--warning); }
        .folder { color: var(--accent); }

        /* Utility classes */
        .hidden { display: none !important; }

        .file-hash {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9em;
            color: var(--accent);
        }

        .error {
            color: var(--error);
            background: rgba(244, 67, 54, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid rgba(244, 67, 54, 0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Column resizer */
        .resizer {
            position: absolute;
            right: -3px;
            top: 0;
            height: 100%;
            width: 6px;
            background: rgba(255, 255, 255, 0.1);
            cursor: col-resize;
            z-index: 1000;
            transition: background 0.3s ease;
        }

        .resizer:hover { background: var(--primary); }

        /* Responsive design */
        @media (max-width: 768px) {
            .container { padding: 0 1rem; }
            .dropzones { flex-direction: column; }
            .dropzone { padding: 1.5rem; }
            .progress-details { flex-direction: column; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1><span class="material-icons">verified</span>Steam Manifest Hash Checker</h1>
    </header>

    <div class="container">
        <div class="dropzones">
            <div class="dropzone" id="drop-zone">
                <span class="material-icons">upload_file</span>
                Drop Steam manifest file here
                <input type="file" id="file-input" style="display: none">
            </div>

            <div class="dropzone" id="dir-zone">
                <span class="material-icons">folder_open</span>
                Drop files to validate here
                <input type="file" id="dir-input" style="display: none" webkitdirectory directory multiple>
            </div>
        </div>

        <div id="error" class="error hidden">
            <span class="material-icons">error</span>
            <span class="error-message"></span>
        </div>

        <div id="metadata" class="section hidden">
            <h2><span class="material-icons">info</span>Manifest Info</h2>
            <table>
                <tr><td>Depot ID:</td><td id="depot-id"></td></tr>
                <tr><td>Manifest ID:</td><td id="manifest-gid"></td></tr>
                <tr><td>Creation Date:</td><td id="creation-time"></td></tr>
                <tr><td>Total Files:</td><td id="total-files"></td></tr>
                <tr><td>Completed Files:</td><td><span id="completed-files">0</span>/<span id="total-checkable-files">0</span></td></tr>
                <tr><td>Status:</td><td id="completion-status">Not Started</td></tr>
                <tr><td>Total Size:</td><td id="total-size"></td></tr>
            </table>
        </div>

        <div id="files" class="section hidden">
            <h2><span class="material-icons">folder</span>Files</h2>
            <div class="search-container">
                <span class="material-icons search-icon">search</span>
                <input type="text" id="search" class="search" placeholder="Search files...">
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th class="filename-col">Filename<div class="resizer" data-column="0"></div></th>
                            <th class="size-col">Size<div class="resizer" data-column="1"></div></th>
                            <th class="hash-col">Hash<div class="resizer" data-column="2"></div></th>
                            <th class="status-col">Status<div class="resizer" data-column="3"></th>
                        </tr>
                    </thead>
                    <tbody id="file-list"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
    // Progress Tracker Class
    class ProgressTracker {
        constructor() {
            this.startTime = null;
            this.processedBytes = 0;
            this.totalBytes = 0;
            this.processed = 0;
            this.total = 0;
            this.recentSpeeds = [];
            this.lastUpdateTime = null;
        }

        start(files) {
            this.startTime = Date.now();
            this.lastUpdateTime = this.startTime;
            this.total = files.length;
            this.processed = 0;
            this.totalBytes = Array.from(files).reduce((sum, file) => sum + file.size, 0);
            this.processedBytes = 0;
            this.recentSpeeds = [];
        }

        update(processedFile) {
            this.processed++;
            this.processedBytes += processedFile.size;
            
            const currentTime = Date.now();
            const timeDiff = (currentTime - this.lastUpdateTime) / 1000;
            
            if (timeDiff > 0) {
                const bytesPerSecond = processedFile.size / timeDiff;
                this.recentSpeeds.push(bytesPerSecond);
                
                if (this.recentSpeeds.length > 5) {
                    this.recentSpeeds.shift();
                }
            }
            
            this.lastUpdateTime = currentTime;
        }

        getStats() {
            const currentTime = Date.now();
            const elapsedSeconds = (currentTime - this.startTime) / 1000;
            
            const avgSpeed = this.recentSpeeds.length > 0 
                ? this.recentSpeeds.reduce((a, b) => a + b) / this.recentSpeeds.length 
                : this.processedBytes / elapsedSeconds;
            
            const remainingBytes = this.totalBytes - this.processedBytes;
            const estimatedRemainingSeconds = avgSpeed > 0 ? remainingBytes / avgSpeed : 0;
            
            return {
                progress: (this.processed / this.total) * 100,
                processedFiles: this.processed,
                totalFiles: this.total,
                speed: avgSpeed,
                remainingTime: estimatedRemainingSeconds,
                elapsedTime: elapsedSeconds
            };
        }

        formatTime(seconds) {
            if (seconds < 60) {
                return `${Math.round(seconds)}s`;
            } else if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.round(seconds % 60);
                return `${minutes}m ${remainingSeconds}s`;
            } else {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                return `${hours}h ${minutes}m`;
            }
        }

        formatSpeed(bytesPerSecond) {
            const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
            let value = bytesPerSecond;
            let unitIndex = 0;
            
            while (value >= 1024 && unitIndex < units.length - 1) {
                value /= 1024;
                unitIndex++;
            }
            
            return `${value.toFixed(1)} ${units[unitIndex]}`;
        }
    }

    // Create Web Worker for hash computation
    const hashWorker = new Worker(URL.createObjectURL(new Blob([`
        self.onmessage = async function(e) {
            const { buffer, id } = e.data;
            try {
                const hash = await crypto.subtle.digest('SHA-1', buffer);
                const hashHex = Array.from(new Uint8Array(hash))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                self.postMessage({ id, hash: hashHex, status: 'complete' });
            } catch (error) {
                self.postMessage({ id, error: error.message, status: 'error' });
            }
        };
    `], { type: 'application/javascript' })));

    // Utility functions
    const utils = {
        formatSize(size) {
            const units = ['B', 'KB', 'MB', 'GB'];
            let value = typeof size === 'bigint' ? Number(size) : Number(size);
            let unit = 0;
            while (value >= 1024 && unit < units.length - 1) {
                value /= 1024;
                unit++;
            }
            return `${Math.round(value * 100) / 100} ${units[unit]}`;
        },

        formatHash(hash) {
            return Array.from(hash)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        },

        formatDate(date) {
            return new Intl.DateTimeFormat('default', {
                year: 'numeric',
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            }).format(date);
        },

        isFolder(hash) {
            return this.formatHash(hash) === '0000000000000000000000000000000000000000';
        },

        showError(message) {
            const error = document.getElementById('error');
            error.innerHTML = `
                <span class="material-icons">error</span>
                <span class="error-message">${message}</span>
            `;
            error.classList.remove('hidden');
            document.getElementById('metadata').classList.add('hidden');
            document.getElementById('files').classList.add('hidden');
        },

        hideError() {
            document.getElementById('error').classList.add('hidden');
        },

        updateStatus(element, status) {
            const icons = {
                match: 'check_circle',
                mismatch: 'error',
                pending: 'pending',
                folder: 'folder'
            };
            element.innerHTML = `
                <span class="material-icons">${icons[status]}</span>
                ${status}
            `;
            element.className = `status ${status}`;
        }
    };

    // Binary Reader Class
    class BinaryReader {
        constructor(buffer) {
            this.view = new DataView(buffer);
            this.offset = 0;
        }

        readUint32() {
            const value = this.view.getUint32(this.offset, true);
            this.offset += 4;
            return value;
        }

        readUint64() {
            const low = this.view.getUint32(this.offset, true);
            const high = this.view.getUint32(this.offset + 4, true);
            this.offset += 8;
            return high * 0x100000000 + low;
        }

        readBytes(length) {
            const bytes = new Uint8Array(this.view.buffer, this.offset, length);
            this.offset += length;
            return bytes;
        }

        hasMore() {
            return this.offset < this.view.byteLength;
        }
    }

    // File Data Class
    class FileData {
        constructor() {
            this.FileName = '';
            this.FileHash = new Uint8Array();
            this.TotalSize = 0n;
        }
    }

    // Depot Manifest Class
    class DepotManifest {
        static PROTOBUF_PAYLOAD_MAGIC = 0x71F617D0;
        static PROTOBUF_METADATA_MAGIC = 0x1F4812BE;
        static PROTOBUF_SIGNATURE_MAGIC = 0x1B81B817;
        static PROTOBUF_ENDOFMANIFEST_MAGIC = 0x32C415AB;

        constructor() {
            this.Files = [];
            this.DepotID = 0;
            this.ManifestGID = 0n;
            this.CreationTime = new Date();
            this.TotalUncompressedSize = 0n;
        }

        static async deserialize(buffer) {
            const manifest = new DepotManifest();
            const reader = new BinaryReader(buffer);

            while (reader.hasMore()) {
                const magic = reader.readUint32();
                if (magic === this.PROTOBUF_ENDOFMANIFEST_MAGIC) break;

                const length = reader.readUint32();
                const data = reader.readBytes(length);

                if (magic === this.PROTOBUF_PAYLOAD_MAGIC) manifest.parsePayload(data);
                else if (magic === this.PROTOBUF_METADATA_MAGIC) manifest.parseMetadata(data);
            }

            return manifest;
        }

        parseVarint(bytes, offset = 0) {
            let value = 0n;
            let shift = 0n;
            let index = offset;

            while (index < bytes.length) {
                const byte = bytes[index++];
                value |= BigInt(byte & 0x7F) << shift;
                if ((byte & 0x80) === 0) break;
                shift += 7n;
            }

            return [value, index - offset];
        }

        readProtoField(bytes, offset) {
            const [tag, tagLen] = this.parseVarint(bytes, offset);
            const fieldNum = Number(tag >> 3n);
            const wireType = Number(tag & 0x07n);
            offset += tagLen;

            let value, valueLen;

            if (wireType === 0) {
                [value, valueLen] = this.parseVarint(bytes, offset);
            } else if (wireType === 2) {
                [value, valueLen] = this.parseVarint(bytes, offset);
                const strLen = Number(value);
                value = bytes.slice(offset + valueLen, offset + valueLen + strLen);
                valueLen += strLen;
            } else {
                throw new Error(`Unsupported wire type: ${wireType}`);
            }

            return { fieldNum, value, bytesRead: tagLen + valueLen };
        }

        parsePayload(data) {
            let offset = 0;
            while (offset < data.length) {
                const field = this.readProtoField(data, offset);
                offset += field.bytesRead;

                if (field.fieldNum === 1) {
                    const mapping = field.value;
                    let mappingOffset = 0;
                    const fileInfo = new FileData();

                    while (mappingOffset < mapping.length) {
                        const mappingField = this.readProtoField(mapping, mappingOffset);
                        mappingOffset += mappingField.bytesRead;

                        switch (mappingField.fieldNum) {
                            case 1: fileInfo.FileName = new TextDecoder().decode(mappingField.value); break;
                            case 2: fileInfo.TotalSize = Number(mappingField.value); break;
                            case 5: fileInfo.FileHash = mappingField.value; break;
                        }
                    }

                    if (fileInfo.FileName) this.Files.push(fileInfo);
                }
            }
        }

        parseMetadata(data) {
            let offset = 0;
            while (offset < data.length) {
                const field = this.readProtoField(data, offset);
                offset += field.bytesRead;

                switch (field.fieldNum) {
                    case 1: this.DepotID = Number(field.value); break;
                    case 2: this.ManifestGID = field.value; break;
                    case 3: this.CreationTime = new Date(Number(field.value) * 1000); break;
                    case 5: this.TotalUncompressedSize = field.value; break;
                }
            }
        }
    }

    function createProgressBar() {
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container';
        progressContainer.innerHTML = `
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <div class="progress-stats">
                <div class="progress-text">
                    <span class="material-icons">task_alt</span>
                    <span>0/0 files processed</span>
                </div>
                <div class="progress-details">
                    <span><span class="material-icons">speed</span>Speed: --</span>
                    <span><span class="material-icons">schedule</span>Elapsed: --</span>
                    <span><span class="material-icons">update</span>Remaining: --</span>
                </div>
            </div>
        `;
        document.querySelector('.container').insertBefore(progressContainer, document.getElementById('files'));
        return progressContainer;
    }

    // Main handlers
    async function handleDirectory(files) {
        if (!files.length || !window.currentManifest) {
            utils.showError(!window.currentManifest ? 'Load manifest first' : 'No files selected');
            return;
        }

        utils.hideError();
        const progressBar = createProgressBar();
        const progressTracker = new ProgressTracker();
        progressTracker.start(files);

        const updateProgressDisplay = () => {
            const stats = progressTracker.getStats();
            const container = progressBar;
            
            container.querySelector('.progress-fill').style.width = `${stats.progress}%`;
            container.querySelector('.progress-text span:last-child').textContent = 
                `${stats.processedFiles}/${stats.totalFiles} files processed`;
            
            const details = container.querySelector('.progress-details').children;
            details[0].innerHTML = `<span class="material-icons">speed</span>Speed: ${progressTracker.formatSpeed(stats.speed)}`;
            details[1].innerHTML = `<span class="material-icons">schedule</span>Elapsed: ${progressTracker.formatTime(stats.elapsedTime)}`;
            details[2].innerHTML = `<span class="material-icons">update</span>Remaining: ${progressTracker.formatTime(stats.remainingTime)}`;
        };

        hashWorker.onmessage = (e) => {
            const { hash, status } = e.data;
            if (status === 'complete') {
                progressTracker.update(files[progressTracker.processed]);
                updateProgressDisplay();
                updateFileStatuses(hash);

                if (progressTracker.processed === progressTracker.total) {
                    progressBar.remove();
                }
            }
        };

        try {
            for (const [index, file] of Array.from(files).entries()) {
                const buffer = await file.arrayBuffer();
                hashWorker.postMessage({ buffer, id: index }, [buffer]);
            }
        } catch (error) {
            console.error('Error:', error);
            utils.showError(error.message);
            progressBar.remove();
        }
    }

    function updateFileStatuses(hash) {
        const manifestHashes = window.currentManifest.Files.map(f => utils.formatHash(f.FileHash));
        const matchStatus = manifestHashes.includes(hash) ? 'match' : 'mismatch';
        
        document.querySelectorAll('#file-list tr').forEach(row => {
            const hashCell = row.querySelector('.file-hash');
            if (hashCell && hashCell.textContent === hash) {
                utils.updateStatus(row.querySelector('.status'), matchStatus);
            }
        });

        const completedFiles = document.querySelectorAll('#file-list tr .status.match, #file-list tr .status.mismatch').length;
        const totalCheckableFiles = document.querySelectorAll('#file-list tr').length - 
            document.querySelectorAll('#file-list tr .status.folder').length;
        
        document.getElementById('completed-files').textContent = completedFiles;
        document.getElementById('total-checkable-files').textContent = totalCheckableFiles;
        
        const completionStatus = document.getElementById('completion-status');
        const statusType = completedFiles === 0 ? 'pending' : 
                          completedFiles < totalCheckableFiles ? 'pending' : 'match';
        utils.updateStatus(completionStatus, statusType);
    }

    async function handleFiles(files) {
        if (!files.length) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                utils.hideError();
                const manifest = await DepotManifest.deserialize(e.target.result);
                displayManifest(manifest);
            } catch (err) {
                console.error('Error:', err);
                utils.showError('Invalid manifest file');
            }
        };

        reader.readAsArrayBuffer(files[0]);
    }

    function displayManifest(manifest) {
        try {
            window.currentManifest = manifest;
            
            document.getElementById('depot-id').textContent = manifest.DepotID;
            document.getElementById('manifest-gid').textContent = manifest.ManifestGID?.toString();
            document.getElementById('creation-time').textContent = utils.formatDate(manifest.CreationTime);
            
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            
            manifest.Files.forEach(file => {
                const row = document.createElement('tr');
                const isFolder = utils.isFolder(file.FileHash);
                row.innerHTML = `
                    <td>${file.FileName}</td>
                    <td>${isFolder ? 'Folder' : utils.formatSize(file.TotalSize)}</td>
					<td class="file-hash">${isFolder ? 'Folder' : utils.formatHash(file.FileHash)}</td>
                    <td class="status ${isFolder ? 'folder' : 'pending'}">
                        <span class="material-icons">${isFolder ? 'folder' : 'pending'}</span>
                        ${isFolder ? 'Folder' : 'pending'}
                    </td>
                `;
                fileList.appendChild(row);
            });
            
            // Calculate totals excluding folders
            const nonFolderFiles = manifest.Files.filter(file => !utils.isFolder(file.FileHash));
            const totalFiles = nonFolderFiles.length;
            const totalSize = nonFolderFiles.reduce((sum, file) => sum + BigInt(file.TotalSize), 0n);

            // Update UI elements
            document.getElementById('total-files').textContent = totalFiles;
            document.getElementById('total-checkable-files').textContent = totalFiles;
            document.getElementById('completed-files').textContent = '0';
            document.getElementById('total-size').textContent = utils.formatSize(totalSize);
            utils.updateStatus(document.getElementById('completion-status'), 'pending');

            // Show sections
            document.getElementById('metadata').classList.remove('hidden');
            document.getElementById('files').classList.remove('hidden');
            utils.hideError();
        } catch (err) {
            console.error('Error:', err);
            utils.showError(err.message);
        }
    }

    // UI initialization
    class UIManager {
        constructor() {
            this.bindEvents();
            this.initializeResizing();
        }

        bindEvents() {
            // Drop zone events
            ['drop-zone', 'dir-zone'].forEach(id => {
                const element = document.getElementById(id);
                const input = document.getElementById(id === 'drop-zone' ? 'file-input' : 'dir-input');
                
                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    element.classList.remove('drag-over');
                    if (id === 'drop-zone') handleFiles(e.dataTransfer.files);
                    else handleDirectory(e.dataTransfer.files);
                });

                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    element.classList.add('drag-over');
                });

                element.addEventListener('dragleave', () => {
                    element.classList.remove('drag-over');
                });

                element.addEventListener('click', () => input.click());
                input.addEventListener('change', (e) => {
                    if (id === 'drop-zone') handleFiles(e.target.files);
                    else handleDirectory(e.target.files);
                });
            });

            // Search functionality
            document.getElementById('search').addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('#file-list tr').forEach(row => {
                    row.style.display = row.textContent.toLowerCase().includes(term) ? '' : 'none';
                });
            });
        }

        initializeResizing() {
            let isResizing = false;
            let currentTh = null;
            let startX = null;
            let startWidth = null;

            document.querySelectorAll('.resizer').forEach(resizer => {
                resizer.addEventListener('mousedown', e => {
                    isResizing = true;
                    currentTh = e.target.parentElement;
                    startX = e.pageX;
                    startWidth = currentTh.offsetWidth;
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    e.preventDefault();
                });
            });

            const onMouseMove = (e) => {
                if (!isResizing) return;
                currentTh.style.width = `${startWidth + (e.pageX - startX)}px`;
            };

            const onMouseUp = () => {
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
        }
    }

    // Initialize the application
    new UIManager();
    </script>
</body>
</html>