<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Manifest/SHA1 Hash Checker</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <!-- Required external resources -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono&display=swap"rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4.11.0/dist/sha1.umd.min.js"></script>
    <style>
        :root[data-theme="dark"] {
            --bg: #121212;
            --text: #e0e0e0;
            --border: #2f2f2f;
            --hover: #1f1f1f;
            --primary: #808080;
            --primary-dark: #666666;
            --primary-light: #a0a0a0;
            --metallic: linear-gradient(145deg, #1a1a1a, #121212);
            --metallic-hover: linear-gradient(145deg, #1f1f1f, #171717);
            --accent: #808080;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="blue"] {
            --bg: #1a1f2e;
            --text: #e0e6f2;
            --border: #2a3242;
            --hover: #2d344c;
            --primary: #4a74c9;
            --primary-dark: #385fa8;
            --primary-light: #6189d8;
            --metallic: linear-gradient(145deg, #2a3242, #1e2433);
            --metallic-hover: linear-gradient(145deg, #2d344c, #212737);
            --accent: #64b5f6;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="light"] {
			--bg: #ffffff;
			--text: #333333;
			--border: #dddddd;
			--hover: #f5f5f5;
			--primary: #555555;      /* Darker for better visibility */
			--primary-dark: #e0e0e0;
			--primary-light: #666666;
			--metallic: linear-gradient(145deg, #ffffff, #f8f8f8);
			--metallic-hover: linear-gradient(145deg, #f8f8f8, #f0f0f0);
			--accent: #555555;
			--success: #4caf50;
			--error: #f44336;
			--warning: #ff9800;
		}
        :root[data-theme="steam"] {
            --bg: #171a21;
            --text: #c6d4df;
            --border: #2a475e;
            --hover: #1b2838;
            --primary: #66c0f4;
            --primary-dark: #1b2838;
            --primary-light: #c7d5e0;
            --metallic: linear-gradient(145deg, #1b2838, #171a21);
            --metallic-hover: linear-gradient(145deg, #2a475e, #1b2838);
            --accent: #66c0f4;
            --success: #a4d007;
            --error: #cc3d3d;
            --warning: #ffa500;
        }
        :root[data-theme="synthwave"] {
			--bg: #1a1a2e;
			--text: #ff9ecd;
			--border: #342c56;
			--hover: #261d47;
			--primary: #f97bc1;
			--primary-dark: #fc2fa2;
			--primary-light: #ffb8e0;
			--metallic: linear-gradient(145deg, #2d1f54, #1a1a2e);
			--metallic-hover: linear-gradient(145deg, #342c56, #2d1f54);
			--accent: #3bfff9;
			--success: #72f1b8;
			--error: #ff3d81;
			--warning: #ffd319;
		}
		:root[data-theme="ocean"] {
			--bg: #0a192f;
			--text: #8892b0;
			--border: #1b3a57;
			--hover: #172a45;
			--primary: #64ffda;
			--primary-dark: #48d6b5;
			--primary-light: #7fffdf;
			--metallic: linear-gradient(145deg, #1b3a57, #0a192f);
			--metallic-hover: linear-gradient(145deg, #234668, #1b3a57);
			--accent: #00b4d8;
			--success: #2dd4bf;
			--error: #ef476f;
			--warning: #ffd60a;
			}
		:root[data-theme="forest"] {
			--bg: #1b2717;
			--text: #d8e2d5;
			--border: #2d3f24;
			--hover: #233019;
			--primary: #90b474;
			--primary-dark: #6a9547;
			--primary-light: #b1cc9a;
			--metallic: linear-gradient(145deg, #2d3f24, #1b2717);
			--metallic-hover: linear-gradient(145deg, #34492a, #2d3f24);
			--accent: #e9f5db;
			--success: #77dd77;
			--error: #ff6b6b;
			--warning: #ffd93d;
		}
		:root[data-theme="solarized"] {
			--bg: #002b36;
			--text: #839496;
			--border: #073642;
			--hover: #003847;
			--primary: #2aa198;
			--primary-dark: #1f7972;
			--primary-light: #35c8bd;
			--metallic: linear-gradient(145deg, #073642, #002b36);
			--metallic-hover: linear-gradient(145deg, #0b4653, #073642);
			--accent: #268bd2;
			--success: #859900;
			--error: #dc322f;
			--warning: #b58900;
		}
        :root {
            --radius: 12px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            margin: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: var(--metallic);
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .theme-toggle {
            position: relative;
        }
        .theme-toggle select {
            appearance: none;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
            font-size: 0.9rem;
        }
        .theme-toggle select:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .theme-toggle select option {
            background: var(--bg);
            color: var(--text);
            padding: 0.5rem;
        }
        .theme-toggle::after {
            content: "palette";
            font-family: "Material Icons";
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text);
        }
        .toggle-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
        }
        .toggle-button:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .toggle-button .material-icons {
            font-size: 1.25rem;
        }
        .dropzones {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .dropzone {
            flex: 1;
            border: 2px dashed var(--primary);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            background: var(--metallic);
            transition: var(--transition);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            position: relative;
        }
        .dropzone input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        .dropzone:hover, .dropzone.drag-over {
            background: var(--metallic-hover);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }
        .section {
            background: var(--metallic);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
        }
        .progress-container {
            margin: 1.5rem 0;
            background: var(--metallic);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            width: 0;
            transition: width 0.3s ease;
        }
        .table-container {
            overflow-x: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: rgba(42, 50, 66, 0.5);
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto;
        }
        th {
            position: sticky;
            top: 0;
            background: var(--primary-dark);
            color: var(--text);
            border-bottom: 2px solid var(--border);
            padding: 0.75rem 1rem;
            font-weight: 500;
            text-align: left;
            white-space: nowrap;
        }
        [data-theme="light"] th {
            color: #333333 !important;
            background: #e0e0e0;
        }
        [data-theme="light"] .dropzone {
            border-color: #555555;
            color: #333333;
        }

        [data-theme="light"] .material-icons {
            color: #555555;
        }
        [data-theme="light"] .dropzone:hover,
        [data-theme="light"] .dropzone.drag-over {
            border-color: #333333;
            background: var(--hover);
        }
        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .match {
            color: var(--success);
        }
        .mismatch {
            color: var(--error);
        }
        .pending {
            color: var(--warning);
        }
        .folder {
            color: var(--accent);
        }
        .hidden {
            display: none !important;
        }
        .error {
            color: var(--error);
            background: rgba(244, 67, 54, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid rgba(244, 67, 54, 0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }
            .dropzones {
                flex-direction: column;
            }
            .dropzone {
                padding: 1.5rem;
            }
        }
</style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <h1><span class="material-icons">verified</span> Steam Manifest/SHA1 Checker</h1>
            <div class="header-controls">
                <div class="theme-toggle">
                    <select id="theme-select">
                        <option value="dark">Dark Theme</option>
                        <option value="blue">Blue Theme</option>
                        <option value="light">Light Theme</option>
                        <option value="steam">Steam Theme</option>
                        <option value="synthwave">Synthwave Theme</option>
                        <option value="ocean">Ocean Theme</option>
                        <option value="forest">Forest Theme</option>
                        <option value="solarized">Solarized Theme</option>
                    </select>
                </div>
                <button id="folder-toggle" class="toggle-button">
                    <span class="material-icons">folder</span>
                    <span id="folder-toggle-text">Hide Folders</span>
                </button>
            </div>
        </div>
    </header> 
    <!-- Main Container -->
    <div class="container">
        <!-- Drop Zones -->
        <div class="dropzones">
            <div class="dropzone" id="drop-zone">
                <span class="material-icons">upload_file</span>
                Drop Steam manifest or SHA1 file here
                <input type="file" id="file-input">
            </div>
            <div class="dropzone" id="dir-zone">
                <span class="material-icons">folder_open</span>
                Drop folder to verify here
                <input type="file" id="dir-input" webkitdirectory directory>
            </div>
        </div>
        <!-- Error Display -->
        <div id="error" class="error hidden">
            <span class="material-icons">error</span>
            <span class="error-message"></span>
        </div>
        <!-- File Metadata Section -->
        <div id="metadata" class="section hidden">
            <h2>
                <span class="material-icons">info</span>
                File Info
            </h2>
            <table>
                <tr>
                    <td>Type:</td>
                    <td id="file-type"></td>
                </tr>
                <tr>
                    <td>Name:</td>
                    <td id="depot-name"></td>
                </tr>
                <tr>
                    <td>Depot ID:</td>
                    <td id="depot-id"></td>
                </tr>
                <tr>
                    <td>Manifest ID:</td>
                    <td id="manifest-gid"></td>
                </tr>
                <tr>
                    <td>Creation Date:</td>
                    <td id="creation-time"></td>
                </tr>
                <tr>
                    <td>Total Files:</td>
                    <td id="total-files"></td>
                </tr>
                <tr>
                    <td>Total Size:</td>
                    <td id="total-size"></td>
                </tr>
                <tr>
                    <td>Status:</td>
                    <td id="completion-status">Not Started</td>
                </tr>
            </table>
        </div>
        <!-- Mismatches Section -->
        <div id="mismatches" class="section hidden">
            <h2>
                <span class="material-icons" style="color: var(--error);">warning</span>
                Mismatched Files
            </h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 40%">Filename</th>
                            <th style="width: 10%">Size</th>
                            <th style="width: 25%">Expected Hash</th>
                            <th style="width: 25%">Actual Hash</th>
                        </tr>
                    </thead>
                    <tbody id="mismatch-list"></tbody>
                </table>
            </div>
        </div>
        <!-- Files Section -->
        <div id="files" class="section hidden">
            <h2>
                <span class="material-icons">folder</span>
                Files
            </h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 40%">Filename</th>
                            <th style="width: 10%">Size</th>
                            <th style="width: 25%">Hash</th>
                            <th style="width: 25%">Status</th>
                        </tr>
                    </thead>
                    <tbody id="file-list"></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        // Utility class for reading binary data
        class BinaryReader {
            constructor(buffer) {
                this.view = new DataView(buffer);
                this.offset = 0;
            }
            readUint32() {
                const value = this.view.getUint32(this.offset, true);
                this.offset += 4;
                return value;
            }
            readBytes(length) {
                const bytes = new Uint8Array(this.view.buffer, this.offset, length);
                this.offset += length;
                return bytes;
            }
            hasMore() {
                return this.offset < this.view.byteLength;
            }
        }
        // Progress Manager class to handle the progress bar
        const ProgressManager = {
            container: null,
            create() {
                this.container = document.createElement('div');
                this.container.className = 'progress-container';
                this.container.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="progress-stats">
                        <div class="progress-text">
                            <span class="material-icons">task_alt</span>
                            <span>Matched: 
                                <span id="matched-count">0</span>/
                                <span id="total-checkable">0</span>
                            </span>
                            <span class="speed-info">Speed: 
                                <span id="hash-speed">0 MB/s</span>
                            </span>
                        </div>
                    </div>
                `;
                document.querySelector('.container').insertBefore(
                    this.container,
                    document.getElementById('files')
                );
                return this.container;
            },
            update(stats) {
                if (!this.container) return;
                const progress = (stats.matches / stats.total) * 100;
                this.container.querySelector('.progress-fill').style.width = `${progress}%`;
                this.container.querySelector('#matched-count').textContent = stats.matches;
                this.container.querySelector('#total-checkable').textContent = stats.total;
                this.container.querySelector('#hash-speed').textContent = stats.speed;
            },
            remove() {
                if (this.container) {
                    this.container.remove();
                    this.container = null;
                }
            }
        };
        // File Processing Utilities
        const FileProcessor = {
            async readChunk(file, offset, length) {
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsArrayBuffer(file.slice(offset, offset + length));
                });
            },
            getRelativePath(file) {
                let relativePath = file.webkitRelativePath;
                if (!relativePath || relativePath.startsWith('/')) {
                    return file.name;
                }
                const pathParts = relativePath.split('/');
                return pathParts.length > 1 ? pathParts.slice(1).join('/') : file.name;
            },
            createMismatchRow(fileName, fileSize, expectedHash, actualHash) {
                const mismatchRow = document.createElement('tr');
                mismatchRow.innerHTML = `
                    <td>${fileName}</td>
                    <td>${fileSize}</td>
                    <td class="file-hash">${expectedHash}</td>
                    <td class="file-hash">${actualHash}</td>
                `;
                return mismatchRow;
            }
        };
        // General Utility Functions
        const utils = {
            formatSize(bytes) {
                const units = ['B', 'KB', 'MB', 'GB'];
                let value = bytes;
                let unit = 0;
                while (value >= 1024 && unit < units.length - 1) {
                    value /= 1024;
                    unit++;
                }
                return `${value.toFixed(1)} ${units[unit]}`;
            },
            formatHash(hash) {
                return Array.from(hash)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            },
            formatDate(date) {
                return new Intl.DateTimeFormat('default', {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                }).format(date);
            },
            isFolder(hash) {
                return typeof hash === 'string' ?
                    hash === '0000000000000000000000000000000000000000' :
                    this.formatHash(hash) === '0000000000000000000000000000000000000000';
            },
            isNonEmptyFolder(file, allFiles) {
                if (!this.isFolder(file.FileHash)) return false;
                return allFiles.some(f => f.FileName.startsWith(file.FileName + '/'));
            },
            normalizePath(path) {
                path = path.replace(/\\/g, '/');
                path = path.replace(/^\/+|\/+$/g, '');
                path = path.replace(/^\.\//, '');
                path = path.replace(/\/+/g, '/');
                return path.toLowerCase();
            },
            findMatchingFile(fileName) {
                if (!window.currentManifest?.Files) return null;
                // Normalize input path
                const normalizedInput = this.normalizePath(fileName);
                const files = window.currentManifest.Files;
                // 1. Try exact match first (case-insensitive)
                const exactMatch = files.find(f =>
                    this.normalizePath(f.FileName) === normalizedInput
                );
                if (exactMatch) return exactMatch;
                // Get the base name and directory of the input file
                const inputParts = normalizedInput.split('/');
                const inputBaseName = inputParts[inputParts.length - 1];
                const inputDirectory = inputParts.slice(0, -1).join('/');
                // 2. Find all potential matches based on filename
                const candidates = files.filter(f => {
                    const manifestPath = this.normalizePath(f.FileName);
                    const manifestParts = manifestPath.split('/');
                    const manifestBaseName = manifestParts[manifestParts.length - 1];
                    return manifestBaseName === inputBaseName;
                });
                if (candidates.length === 0) return null;
                if (candidates.length === 1) return candidates[0];
                // 3. Multiple candidates - find best match using strict path comparison
                let bestMatch = null;
                let bestScore = -1;
                for (const candidate of candidates) {
                    const manifestPath = this.normalizePath(candidate.FileName);
                    const manifestParts = manifestPath.split('/');
                    const manifestDirectory = manifestParts.slice(0, -1).join('/');
                    let score = 0;
                    // Exact directory match gets highest score
                    if (manifestDirectory === inputDirectory) {
                        score = 1000;
                    }
                    // Partial directory match gets lower score
                    else if (inputDirectory && manifestDirectory) {
                        const inputDirParts = inputDirectory.split('/');
                        const manifestDirParts = manifestDirectory.split('/');
                        // Compare directory parts from right to left
                        for (let i = 1; i <= Math.min(inputDirParts.length, manifestDirParts.length); i++) {
                            if (inputDirParts[inputDirParts.length - i] ===
                                manifestDirParts[manifestDirParts.length - i]) {
                                score += 10;
                            } else {
                                break;
                            }
                        }
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = candidate;
                    }
                }
                return bestScore >= 10 ? bestMatch : null;
            },
            parseSHA1File(content) {
                const lines = content.split(/[\r\n]+/).filter(line => line.trim());
                const files = [];
                const seenFiles = new Set();
                lines.forEach((line, index) => {
                    line = line.trim().replace(/^\uFEFF/, '');
                    if (!line || line.startsWith('#')) return;
                    try {
                        let hash, fileName;
                        let match = line.match(/([a-fA-F0-9]{40})\s+[*]?(.+)/i);
                        if (match) {
                            [, hash, fileName] = match;
                        } else {
                            match = line.match(/SHA1\((.*?)\)[= ]+([a-fA-F0-9]{40})/i);
                            if (match) {
                                [, fileName, hash] = match;
                            } else {
                                match = line.match(/([a-fA-F0-9]{40})/i);
                                if (match) {
                                    hash = match[1];
                                    fileName = line.replace(hash, '').trim();
                                    if (!fileName) fileName = `file_${index}`;
                                }
                            }
                        }
                        if (hash && fileName) {
                            fileName = fileName.trim().replace(/\\/g, '/');
                            const fileKey = `${fileName}|${hash}`;
                            if (!seenFiles.has(fileKey)) {
                                seenFiles.add(fileKey);
                                files.push({
                                    FileName: fileName,
                                    FileHash: hash.toLowerCase(),
                                    TotalSize: 0
                                });
                            }
                        }
                    } catch (err) {
                        console.warn(`Failed to parse line ${index}:`, err);
                    }
                });
                if (files.length === 0) {
                    throw new Error('No valid SHA1 hashes found in file');
                }
                return {
                    Files: files,
                    DepotID: 'SHA1 File',
                    ManifestGID: 'N/A',
                    CreationTime: new Date(),
                    TotalSize: 0,
                    isSHA1File: true
                };
            },
            markPendingAsMissing() {
                document.querySelectorAll('#file-list tr .status.pending').forEach(status => {
                    utils.updateStatus(status, 'mismatch');
                    const row = status.parentElement;
                    const fileName = row.children[0].textContent;
                    const fileSize = row.children[1].textContent;
                    const expectedHash = row.children[2].textContent;
                    const mismatchList = document.getElementById('mismatch-list');
                    const mismatchRow = FileProcessor.createMismatchRow(
                        fileName,
                        fileSize,
                        expectedHash,
                        'File Missing'
                    );
                    mismatchList.appendChild(mismatchRow);
                });
                if (document.getElementById('mismatch-list').children.length > 0) {
                    document.getElementById('mismatches').classList.remove('hidden');
                }
            },
            showError(message) {
                const error = document.getElementById('error');
                error.innerHTML = `
        <span class="material-icons">error</span>
        <span class="error-message">${message}</span>
    `;
                error.classList.remove('hidden');
                document.getElementById('metadata').classList.add('hidden');
                document.getElementById('files').classList.add('hidden');
                document.getElementById('mismatches').classList.add('hidden');
            },
            hideError() {
                document.getElementById('error').classList.add('hidden');
            },
            updateStatus(element, status) {
                const icons = {
                    match: 'check_circle',
                    mismatch: 'error',
                    pending: 'pending',
                    folder: 'folder'
                };
                element.innerHTML = `
        <span class="material-icons">${icons[status]}</span>
        ${status}
    `;
                element.className = `status ${status}`;
            }
        };
        // Depot Manager for handling depot.ini lookups
        const DepotManager = {
    depotData: null,
    lastFetch: 0,
    CACHE_DURATION: 3600000, // 1 hour
    PRIMARY_URL: 'https://raw.githubusercontent.com/Masquerade64/SteamDepotNames/refs/heads/main/depots.ini',
    BACKUP_URL: 'https://raw.githubusercontent.com/SteamDatabase/SteamTracking/master/depots.ini',
    
    async fetchAndParseDepots() {
        let depots = {};
        
        // Try primary URL first
        try {
            console.log('Trying primary URL...');
            const response = await fetch(this.PRIMARY_URL);
            if (response.ok) {
                const text = await response.text();
                depots = { ...depots, ...this.parseDepotsData(text, true) };
                console.log('Primary URL data loaded');
            }
        } catch (error) {
            console.log('Primary URL failed:', error);
        }

        // Always try backup URL
        try {
            console.log('Trying backup URL...');
            const response = await fetch(this.BACKUP_URL);
            if (response.ok) {
                const text = await response.text();
                // Merge with primary data, but don't overwrite existing names
                const backupDepots = this.parseDepotsData(text, false);
                Object.keys(backupDepots).forEach(id => {
                    if (!depots[id]) {
                        depots[id] = backupDepots[id];
                    }
                });
                console.log('Backup URL data loaded');
            }
        } catch (error) {
            console.log('Backup URL failed:', error);
        }

        if (Object.keys(depots).length === 0) {
            throw new Error('Failed to fetch depot data from both sources');
        }

        this.depotData = depots;
        this.lastFetch = Date.now();
        return depots;
    },

    parseDepotsData(text, isPrimary) {
        const depots = {};
        text.split('\n').forEach(line => {
            line = line.trim();
            if (!line || line.startsWith(';')) return;
            
            const match = line.match(/^(\d+)\s*=\s*(.+)$/);
            if (match) {
                const [, id, name] = match;
                if (isPrimary) {
                    // Primary format: just store as-is
                    depots[id] = name.trim();
                } else {
                    // Backup format: clean up the name
                    let cleanName = name.trim()
                        .replace(/(?:content|bin)\w*/gi, '')
                        .replace(/german|french|italian|korean|spanish|russian|japanese|polish|brazilian|tchinese|schinese/gi, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                    depots[id] = cleanName;
                }
            }
        });
        return depots;
    },

    async getDepotName(depotId) {
        if (!this.depotData || Date.now() - this.lastFetch > this.CACHE_DURATION) {
            await this.fetchAndParseDepots();
        }

        return this.depotData[depotId] || null;
    }
    };
// Steam Manifest Parser Class
        class Manifest {
            static PAYLOAD_MAGIC = 0x71F617D0;
            static METADATA_MAGIC = 0x1F4812BE;
            static ENDOFMANIFEST_MAGIC = 0x32C415AB;
            static async fromBuffer(buffer) {
                const reader = new BinaryReader(buffer);
                const manifest = {
                    Files: [],
                    DepotID: 0,
                    ManifestGID: 0,
                    CreationTime: new Date(),
                    TotalSize: 0
                };
                while (reader.hasMore()) {
                    const magic = reader.readUint32();
                    if (magic === this.ENDOFMANIFEST_MAGIC) break;
                    const length = reader.readUint32();
                    const data = reader.readBytes(length);
                    if (magic === this.PAYLOAD_MAGIC) {
                        this.parsePayload(data, manifest);
                    } else if (magic === this.METADATA_MAGIC) {
                        this.parseMetadata(data, manifest);
                    }
                }
                return manifest;
            }
            static parseVarint(bytes, offset = 0) {
                let value = 0n;
                let shift = 0n;
                let index = offset;
                while (index < bytes.length) {
                    const byte = bytes[index++];
                    value |= BigInt(byte & 0x7F) << shift;
                    if ((byte & 0x80) === 0) break;
                    shift += 7n;
                }
                return [value, index - offset];
            }
            static parseProtoField(bytes, offset) {
                const [tag, tagLen] = this.parseVarint(bytes, offset);
                const fieldNum = Number(tag >> 3n);
                const wireType = Number(tag & 0x07n);
                offset += tagLen;
                let value, valueLen;
                if (wireType === 0) {
                    [value, valueLen] = this.parseVarint(bytes, offset);
                } else if (wireType === 2) {
                    [value, valueLen] = this.parseVarint(bytes, offset);
                    const strLen = Number(value);
                    value = bytes.slice(offset + valueLen, offset + valueLen + strLen);
                    valueLen += strLen;
                }
                return {
                    fieldNum,
                    value,
                    bytesRead: tagLen + valueLen
                };
            }
            static parsePayload(data, manifest) {
                let offset = 0;
                while (offset < data.length) {
                    const field = this.parseProtoField(data, offset);
                    offset += field.bytesRead;
                    if (field.fieldNum === 1) {
                        const mapping = field.value;
                        let mappingOffset = 0;
                        const fileInfo = {
                            FileName: '',
                            FileHash: new Uint8Array(),
                            TotalSize: 0
                        };
                        while (mappingOffset < mapping.length) {
                            const mappingField = this.parseProtoField(mapping, mappingOffset);
                            mappingOffset += mappingField.bytesRead;
                            switch (mappingField.fieldNum) {
                                case 1:
                                    fileInfo.FileName = new TextDecoder().decode(mappingField.value);
                                    break;
                                case 2:
                                    fileInfo.TotalSize = Number(mappingField.value);
                                    break;
                                case 5:
                                    fileInfo.FileHash = mappingField.value;
                                    break;
                            }
                        }
                        if (fileInfo.FileName) manifest.Files.push(fileInfo);
                    }
                }
            }
            static parseMetadata(data, manifest) {
                let offset = 0;
                while (offset < data.length) {
                    const field = this.parseProtoField(data, offset);
                    offset += field.bytesRead;
                    switch (field.fieldNum) {
                        case 1:
                            manifest.DepotID = Number(field.value);
                            break;
                        case 2:
                            manifest.ManifestGID = field.value;
                            break;
                        case 3:
                            manifest.CreationTime = new Date(Number(field.value) * 1000);
                            break;
                        case 5:
                            manifest.TotalSize = Number(field.value);
                            break;
                    }
                }
            }
        }
        // Main Functions
        async function handleDirectory(files) {
            if (!files.length || !window.currentManifest) {
                utils.showError(!window.currentManifest ? 'Load manifest or SHA1 file first' : 'No files selected');
                return;
            }
            utils.hideError();
            const progress = ProgressManager.create();
            const sha1 = await hashwasm.createSHA1();
            const chunkSize = 8 * 1024 * 1024;
            let processedBytes = 0;
            let startTime = Date.now();
            try {
                for (const file of files) {
                    sha1.init();
                    let chunkOffset = 0;
                    while (chunkOffset < file.size) {
                        const chunkSize = Math.min(8 * 1024 * 1024, file.size - chunkOffset);
                        const chunk = await FileProcessor.readChunk(file, chunkOffset, chunkSize);
                        sha1.update(new Uint8Array(chunk));
                        processedBytes += chunkSize;
                        chunkOffset += chunkSize;
                        if (chunkOffset === file.size) {
                            const relativePath = FileProcessor.getRelativePath(file);
                            console.log('Processing file:', relativePath); // Debug log
                            updateFileStatuses(sha1.digest(), relativePath);
                        }
                        const elapsed = (Date.now() - startTime) / 1000;
                        const speed = processedBytes / elapsed;
                        ProgressManager.update({
                            matches: document.querySelectorAll('#file-list tr .status.match').length,
                            total: document.querySelectorAll('#file-list tr').length -
                                document.querySelectorAll('#file-list tr .status.folder').length,
                            speed: utils.formatSize(speed) + '/s'
                        });
                    }
                }
            } catch (error) {
                utils.showError(error.message);
            } finally {
                utils.markPendingAsMissing();
                const totalCheckableFiles = document.querySelectorAll('#file-list tr').length -
                    document.querySelectorAll('#file-list tr .status.folder').length;
                const completedFiles = document.querySelectorAll('#file-list tr .status.match').length;
                if (completedFiles === totalCheckableFiles) {
                    ProgressManager.remove();
                }
            }
        }
        async function handleManifestFile(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    utils.hideError();
                    let uploadedManifest;
                    const content = new TextDecoder().decode(e.target.result);
                    if (file.name.toLowerCase().endsWith('.sha1') ||
                        file.type === 'text/plain' ||
                        content.includes('sha1') ||
                        content.match(/[a-fA-F0-9]{40}/i)) {
                        try {
                            uploadedManifest = utils.parseSHA1File(content);
                        } catch (sha1Err) {
                            uploadedManifest = await Manifest.fromBuffer(e.target.result);
                        }
                    } else {
                        uploadedManifest = await Manifest.fromBuffer(e.target.result);
                    }
                    displayManifest(uploadedManifest);
                } catch (err) {
                    console.error('Error parsing file:', err);
                    utils.showError('Invalid file format: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        function updateFileStatuses(hash, fileName) {
            const manifestFile = utils.findMatchingFile(fileName);
            if (!manifestFile || utils.isFolder(manifestFile.FileHash)) return;
            const expectedHash = window.currentManifest.isSHA1File ?
                manifestFile.FileHash :
                utils.formatHash(manifestFile.FileHash);
            const actualHash = typeof hash === 'string' ? hash : utils.formatHash(hash);
            const matchStatus = expectedHash.toLowerCase() === actualHash.toLowerCase() ? 'match' : 'mismatch';
            document.querySelectorAll('#file-list tr').forEach(row => {
                const rowFileName = row.children[0].textContent;
                if (rowFileName === manifestFile.FileName) {
                    utils.updateStatus(row.querySelector('.status'), matchStatus);
                    if (matchStatus === 'mismatch') {
                        const mismatchList = document.getElementById('mismatch-list');
                        const mismatchRow = FileProcessor.createMismatchRow(
                            manifestFile.FileName,
                            row.children[1].textContent,
                            expectedHash,
                            actualHash
                        );
                        mismatchList.appendChild(mismatchRow);
                        document.getElementById('mismatches').classList.remove('hidden');
                    }
                }
            });
            updateCompletionStatus();
        }
        function updateCompletionStatus() {
            const completedFiles = document.querySelectorAll('#file-list tr .status.match').length;
            const totalCheckableFiles = document.querySelectorAll('#file-list tr').length -
                document.querySelectorAll('#file-list tr .status.folder').length;
            const mismatchedFiles = document.querySelectorAll('#file-list tr .status.mismatch').length;
            let statusType = 'pending';
            if (completedFiles > 0) {
                if (completedFiles === totalCheckableFiles) {
                    statusType = mismatchedFiles === 0 ? 'match' : 'mismatch';
                } else if (mismatchedFiles > 0) {
                    statusType = 'mismatch';
                }
            }
            utils.updateStatus(document.getElementById('completion-status'), statusType);
        }
        async function displayManifest(manifest) {
    try {
        window.currentManifest = manifest;
        document.getElementById('mismatch-list').innerHTML = '';
        document.getElementById('mismatches').classList.add('hidden');
        document.getElementById('file-type').textContent = manifest.isSHA1File ? 'SHA1 File' : 'Steam Manifest';
        document.getElementById('depot-id').textContent = manifest.DepotID;
        document.getElementById('manifest-gid').textContent = manifest.ManifestGID?.toString();
        document.getElementById('creation-time').textContent = utils.formatDate(manifest.CreationTime);

        // Add depot name lookup
        try {
            console.log('Fetching depot name for ID:', manifest.DepotID);
            // Remove existing depot name row if it exists
            const existingDepotName = document.getElementById('depot-name');
            if (existingDepotName && existingDepotName.parentElement) {
                existingDepotName.parentElement.remove();
            }
            
            if (!manifest.isSHA1File && manifest.DepotID) {
                const depotName = await DepotManager.getDepotName(manifest.DepotID.toString());
                console.log('Fetched depot name:', depotName);
                
                if (depotName) {
                    const depotIdRow = document.getElementById('depot-id').parentElement;
                    if (depotIdRow && depotIdRow.parentNode) {
                        const depotNameRow = document.createElement('tr');
                        depotNameRow.innerHTML = `
                            <td>Depot Name:</td>
                            <td id="depot-name">${depotName}</td>
                        `;
                        depotIdRow.parentNode.insertBefore(depotNameRow, depotIdRow.nextSibling);
                        console.log('Added depot name row to UI');
                    } else {
                        console.error('Could not find depot-id row or its parent');
                    }
                } else {
                    console.log('No depot name found for ID:', manifest.DepotID);
                }
            } else {
                console.log('Skipping depot name lookup for SHA1 file or invalid depot ID');
            }
        } catch (error) {
            console.error('Error handling depot name:', error);
        }

        // Get the current state of the folder toggle
        const hideFolders = localStorage.getItem('hideFolders') === 'true';
        
        // Filter files based on the toggle state
        const filteredFiles = manifest.Files.filter(file => 
            hideFolders ? !utils.isFolder(file.FileHash) : true
        );
        
        const fileList = document.getElementById('file-list');
        fileList.innerHTML = '';
        
        filteredFiles.forEach(file => {
            const row = document.createElement('tr');
            const isFolder = utils.isFolder(file.FileHash);
            row.innerHTML = `
                <td>${file.FileName}</td>
                <td>${isFolder ? 'Folder' : utils.formatSize(file.TotalSize)}</td>
                <td class="file-hash">${isFolder ? 'Folder' : (manifest.isSHA1File ? file.FileHash : utils.formatHash(file.FileHash))}</td>
                <td class="status ${isFolder ? 'folder' : 'pending'}">
                    <span class="material-icons">${isFolder ? 'folder' : 'pending'}</span>
                    ${isFolder ? 'Folder' : 'pending'}
                </td>
            `;
            fileList.appendChild(row);
        });

        // Only count non-folder files for the totals
        const nonFolderFiles = manifest.Files.filter(file => !utils.isFolder(file.FileHash));
        document.getElementById('total-files').textContent = nonFolderFiles.length;
        document.getElementById('total-size').textContent = utils.formatSize(nonFolderFiles.reduce((sum, file) => 
            sum + Number(file.TotalSize), 0));
        
        utils.updateStatus(document.getElementById('completion-status'), 'pending');
        document.getElementById('metadata').classList.remove('hidden');
        document.getElementById('files').classList.remove('hidden');
        utils.hideError();
    } catch (err) {
        console.error('Error:', err);
        utils.showError(err.message);
    }
}
function initThemes() {
        const themeSelect = document.getElementById('theme-select');
        const savedTheme = localStorage.getItem('theme') || 'steam'; // Default to steam theme
    
        // Set initial theme
        document.documentElement.setAttribute('data-theme', savedTheme);
        themeSelect.value = savedTheme;
    
        // Handle theme changes
        themeSelect.addEventListener('change', (e) => {
            const newTheme = e.target.value;
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    }
        // Initialize the UI
        function initializeUI() {
    document.getElementById('file-input').addEventListener('change', (e) => {
        if (e.target.files[0]) handleManifestFile(e.target.files[0]);
    });

    document.getElementById('dir-input').addEventListener('change', (e) => {
        if (e.target.files.length) handleDirectory(Array.from(e.target.files));
    });

    // Initialize folder toggle
    const folderToggle = document.getElementById('folder-toggle');
    const folderToggleText = document.getElementById('folder-toggle-text');
    
    // Set initial state from localStorage
    let hideFolders = localStorage.getItem('hideFolders') === 'true';
    folderToggleText.textContent = hideFolders ? 'Show Folders' : 'Hide Folders';
    
    folderToggle.addEventListener('click', () => {
        hideFolders = !hideFolders;
        localStorage.setItem('hideFolders', hideFolders);
        folderToggleText.textContent = hideFolders ? 'Show Folders' : 'Hide Folders';
        
        // Refresh the display if we have a manifest loaded
        if (window.currentManifest) {
            displayManifest(window.currentManifest);
        }
    });

    // Initialize themes
    initThemes();

    // Initialize drag and drop for both zones
    ['drop-zone', 'dir-zone'].forEach(id => {
        const element = document.getElementById(id);
        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            element.classList.add('drag-over');
        });

        element.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            element.classList.remove('drag-over');
        });

        element.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            element.classList.remove('drag-over');

            if (id === 'drop-zone' && e.dataTransfer.files[0]) {
                handleManifestFile(e.dataTransfer.files[0]);
            } else if (id === 'dir-zone') {
                const items = e.dataTransfer.items;
                const files = [];

                async function getAllFiles(entry) {
                    return new Promise((resolve) => {
                        if (entry.isFile) {
                            entry.file(file => {
                                // Store the full path without the root folder name
                                const pathParts = entry.fullPath.split('/');
                                file.webkitRelativePath = pathParts.slice(2).join('/') || file.name;
                                files.push(file);
                                resolve();
                            });
                        } else if (entry.isDirectory) {
                            const reader = entry.createReader();
                            reader.readEntries(async (entries) => {
                                const promises = entries.map(entry => getAllFiles(entry));
                                await Promise.all(promises);
                                resolve();
                            });
                        } else {
                            resolve();
                        }
                    });
                }

                const promises = [];
                for (const item of items) {
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry();
                        if (entry) {
                            promises.push(getAllFiles(entry));
                        }
                    }
                }
                await Promise.all(promises);
                if (files.length > 0) {
                    handleDirectory(files);
                }
            }
        });
    });
}
        // Start the application
        initializeUI();
    </script>
</body>
</html>